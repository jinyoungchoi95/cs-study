### Blocking, non-Blocking

 어떤 함수를 실행하고 있을 때 다른 함수를 실행하는 경우가 있다. 

 이때 함수를 실행하는 제어권을 다른 함수가 끝날때까지 주고 기다리는 것이 blocking이고 멀티 스레드 환경과 같이 다른 함수는 실행시키게 두고 제어권을 가져와서 계속 원래 함수를 진행하는 것이 non-blocking이다



### Syn, Async 동기, 비동기

  동기와 비동기의 차이는 함수가 실행되는 과정에서 다른 함수의 실행이 동작될 때 그 함수의 실행과정을 궁금해하느냐 아니냐의 차이이다.

 동기는 다른 함수의 동작이 시작되면 끊임없이 해당 함수가 동작되는 지에 대한 완료 확인을 계속 하며,

 비동기는 마치 스레드가 둘이 있는 것과 같이 다른 함수의 동작이 시작되면 자신의 함수로 돌아와 신경쓰지 않고 자신의 함수를 동작시킨다.



 Blocking과 non-blocking은 동작에 대한 제어권을 어디에 주느냐에 따라서 다르다.

 Blocking은 함수 A에서 함수 B가 실행되었을 때 제어권을 주고 함수 B가 동작이 끝날때까지 제어권을 받지 못해서 함수 A를 실행하지 못하는 상황이 되는 것이고,

 non-Blocking은 함수 A에서 함수 B가 실행되었을 때 제어권을 줬다가 바로 다시 받아서 함수 A를 실행하는 것을 말한다.



 동기Blocking과 비동기non-blocking은 둘 다 blocking의 여부에 따라서 진행이 흘러가지만 나머지 둘이 다르다



### 동기 + non blocking

 동기 non blocking의 경우 동기에 의해서 함수 B가 실행되는 것을 꾸준히 관찰해야한다. non-blocking을 통해서 함수 A가 제어권을 받았지만 동기는 함수 B의 상태를 계속 확인해야하므로 상태 확인에 대한 요청을 B가 끝날때까지 요청한다.



### 비동기 + blocking

 원래 비동기는 함수 A가 동작하는 중에 함수 B가 실행되어도 바로 제어권을 받아서 B가 실행되는동안 신경쓰지않고 함수 A를 동작시킨다.

 근데 Blocking으로 인해서 함수 B에 제어권이 넘어가기 때문에 A는 제어권을 받아서 신경쓰지않고 자신의 동작을 실행하고싶어도 제어권이 B가 끝날때까지 있기 때문에 마치 A가 B를 기다리는 동기Blocking과 똑같은 동작을 하는 것이다.



### 프로세스 동기화

 프로세스가 동기화하기 위해서는 임계영역을 어떻게 관리하는가에 따라서 갈려있다.

 근데 이때 임계영역이란 무엇을 말하는가?



 임계영역은 동일한 자원을 서로다른 스레드, 프로세스가 접근하는 작업을 실행하는 영역을 말한다(Critical section)

 공통된 자원을 접근하는 부분에 있어서 접근하는데 기본 조건이 필요하다. -> **"상호배제"**



 상호 배제란 프로세스 A가 임계영역의 자원을 실행 중이라면 다른 프로세스는 이에 접근하지 못하는 것을 말한다.

 상호 배제를 잘 적용하는 것이 동기화시키는데에 핵심이라고 볼 수 있다.



 이를 위한 해결책으로는 Lock이 기반된 동기화를 사용한다. 

 Locking이란 사용되고 있는 임계영역에 대해서 Lock으로 접근 권한을 걸고 사용이 종료되었을 때 unLock을 함으로써 동시에 여러 프로세스가 임계영역에 접근하지 못하게 하는 방식이다.



 뮤텍스, 세마포어, 모니터 등등의 동기화기법이 있다.

### 뮤텍스

 사용되고 있는 임계영역에 대해 Lock을 걸고, 사용이 종료되었을 때 unLock을 하여서 동시에 여러 프로세스가 임계영역에 접근하지 못하게 하는 방식이다.

 만약에 Lock된 임계 영역에 접근하게 될 경우 권한을 획득할 때까지 요청하지 않고, 컨텍스트 스위칭을 통해 접근 권한 요청을 한다. 단 프로세스의 컨텍스트 스위칭의 경우 사용시마다 캐시메모리를 초기화해야하기 때문에 오버로드가 발생할 수 있다.



 비슷한 방식으로 사용하는 스핀락(spin lock)이 있는데 lock이 걸리고 unlock이 되어야 다른 프로세스가 접근할 수 있는 것은 동일하지만 busy wait 상태로 unlock이 될 때까지 cpu에 계속 요청을 하기 때문에 오버로드가 발생할 수 있다.



### 세마포어

 공통으로 관리하는 하나의 값을 이용해서 상호 배제를 달성하는 것을 말한다.

 임계 영역 하나에 대해서 접근할 수 있는 스레드 혹은 프로세스의 개수를 제한을 하는데 뮤텍스의 경우에는 lock을 건 주체만이 unlock을 할 수 있는 반면에 세마포어는 동기화를 위해서 두 개의 연산을 사용한다. wait와 signal을 통해서 wait를 호출하면 signal 카운트를 줄이고 카운트가 0이라면 wait하지 못하는 것을 말한다.



 물론 signal count를 1로두면 뮤텍스와 세마포어는 비슷한 동작을 하는 것처럼 보인다. 단, 뮤텍스는 wait를 건 대상만이 lock을 풀 수 있지만 세마포어는 wait 요청을 못해서 lock을 못푸는 것이 아닌 signal count가 0이기 때문에 요청을 못거는 것이다.



### 데드락

 멀티 환경에서 자원을 요청해서 자원을 기다리지만 자원을 가지지 못하는 상황을 말한다.

 발생 조건은 4가지가 있는데

- 상호배제 : 여러 스레드가 동시에 사용 못하고, 개수가 제한적일 때
- Lock, wait : 스레드가 자원을 점유하면 작업을 마칠때까지 점유한 자원을 내놓지 않는 것
- 선점 불가 : 스레드가 다른 스레드로부터 자원을 빼앗지 못하는 경우
- 순환대기 : 스래드가 필요한 자원이 서로 다른 스레드에 있는 경우

를 말한다.



 데드락을 깨기 위해서는 이 4가지를 피해야한다.

1. 상호배제

    동시에 사용해도 괜찮은 자원을 사용한다. 또한 자원의 수를 스레드 수 이상으로 늘리면 다른 스레드도 접근이 가능해진다.

2. wait lock

    아예 대기를 하지 않는 전략. 필요한 자원이 있는지 먼저 파악하고 없으면 자원을 내놓고 대기함.

3. 선점불가

    자원이 필요할 경우 자원을 소유한 스레드에게 자원 요청을 하는 것. 단, 요청받은 스레드는 자신의 자원을 풀어주고 처음부터 다시 시작한다.

4. 순환대기

    자원들에게 순서를 준 뒤에 각 스레드들이 자원을 요청할 때 우선도가 증가하는 순으로 요청하는 것. 요청자원보다 우선도가 큰 자을 전부 해제
