### 데이터 베이스 특징

- 통합된 데이터
- 저장된 데이터
- 운영 데이터
- 공용 데이터



### 인덱스

 데이터베이스에서 테이블에 대한 동작의 속도를 높여주는 일종의 자료구조인다.

 데이터베이스의 원하는 검색 결과를 찾으려면 모든 데이터를 검색해야하기 때문에 오랜 시간이 걸린다. 따라서 데이터에 대해서 책의 페이지 번호를 매기듯이 각각에 인덱스 번호를 매겨두어 컬럼의 값과 레코드가 저장된 주소를 연결하여 인덱스로 만들어 검색을 빠르게 하는 것입니다.



 물론 인덱스는 데이터의 읽기 속도를 높이는 기능이기때문에 데이터를 삭제, 수정하는 경우에는 쿼리 실행 속도가 느려진다.



### 인덱스 검색에 사용하는 알고리즘

### B Tree

 이진트리를 확장해서 더 많은 수의 자식을 갖게 일반화시킨 트리. 노드의 자료수가 N개 이면 자식의 수는 N+1개인 구조

### B+Tree

 B Tree에서 leaf노드끼리 연결리스트로 연결되어 있음

 컬럼의 값을 변형하기 앖고 원래의 값을 이용해서 인덱싱하는 알고리즘

### Hash 인덱스 알고리즘

 칼럼값을 해시값으로 계산해서 인덱싱하는 알고리즘으로 매우 빠른 검색을 지원한다.

 값의 일부분으로 ex)Like연산, 검색을 하는 경우 해시 인덱스를 사용할 수 없다.



### B-Tree를 사용하는 이유

 물론 Hash Table이 시간복잡도가 O(1)이기 때문에 검색하는 속도는 더 빠를 수 있지만 HashTable의 경우 동등연산에만 특화되어있고 부등호 연산은 검색을 하기 힘들다. 또한 Like같이 값의 일부분으로만 검색하는 검색방법은 사용할 수 없기 때문에 B-Tree를 사용한다.



### 클러스터 인덱스

 클러스터라는 뜻은 군집으로 인덱스에서 클러스터는 비슷한 것들을 묶어서 저장하는 형태를 말한다. 따라서 비슷한 값끼리는 물리적으로 인접한 위치에 저장되어있는 데이터가 되는 것이다.

 클러스터 인덱스는 테이블의 pk 에 대해서만 즉, pk 값이 비슷한 레코드끼리 저장하는 것을 말한다. 따라서 클러스터 인덱스는 프라이머리 키값에 의해 레코드 저장위치가 결정되며, pk가 바뀌면 물리적인 저장위치 또한 변경되기 때문에 신중하게 결정하여 사용해야 한다.



### 트랜잭션

 데이터의 정합성을 보존하기 위한 작업이다.

 로직이 진행하다가 중간에 에러가나서 멈추게될 경우 로직을 저장하는 것이 아닌, 중간에 에러가 나지 않고 완전히 로직이 종료되었을때 작업내용을 저장하는 것을 말한다.

 Active - partially commit - commit - failed - aborted



### ACID

- 원자성 : 트랜잭션이 완전히 종료된 후에만 commit해야한다.
- 일관성 : 트랜잭션이 진행된 후에도 트랜잭선이 일어나기 전의 상황과 동일하게 일관성을 유지해야한다.
- 독립성 : 트랜잭션은 서로다른 트랜잭션에 관여없이 독립적으로 수행되어야한다.
- 지속성 : 트랜잭션이 일어난 후에는 데이터베이스에 작업결과가 존재해야한다.



### 트랜잭션 격리수준



### 1. Read uncommited

 트랜잭션이 커밋되지 않았는데도 다른 트랜잭션이 접근이 가능한 상황

 트랜잭션 A가 update했고 B가 그걸 select 했지만 A를 롤백해버리면 잘못된 데이터를 검색하는 Dirty read가 걸림.

### 2. Read commited

 커밋이 완료된 트랜잭션의 변경사항만 접근 가능

 단 커밋이 완료되지 않은 데이터에 대해서는 Undo에 백업된 데이터를 가져온다.  동일 트랜잭션에서 다시 조회했을 때 데이터가 달라진다.

 이때 트랜잭션 A가 실행되고 B가 후에 실행이 되었을 때 트랜잭션 B가 commit되기 전에 값에 대해서는 Undo에 백업된 데이터를 가져오지만, commit된 후의 데이터는 변경된 데이터를 가져오기 때문에 둘의 데이터 정합성 차이가 남

### 3. Repetable Read

 트랜잭션이 시작되기 전 커밋이 완료된 값에 대해서만 조회 가능

 단 update에 대해서 Undo에 백업을 하는 형태로 저장하기 때문에 새로운 데이터가 들어오는 경우에 대해서 혹은 삭제되는 경우에 대해서 Phantom read를 막기가 힘들다.

 따라서 쓰기 잠금에 대한 고려가 필요하다

### 4. Serialzable

 모든 부분에 대해 격리된 상태





### 데이터 요청이 많이 들어올 때

 한번에 많은 데이터를 처리해야하는 상황이 온다면 index는 조회가 메인인 서비스에만 좋고 update, insert, delete가 잦은 요청이 일어날 경우 옳은 방법은 아닐 것이다.

 그럼 데이터를 분산해야하는데 분산하는데는 여러가지가 있다.



###  Replication

 같은 데이터를 복사해서 여러 노드에 분산시키는 방법이다. 마스터 노드와 슬레이브 노드를 구분지어 마스터노드에서는 cud를, 슬레이브 노드에서는 r를 진행하여 부하를 분산시키는 방법이다.
