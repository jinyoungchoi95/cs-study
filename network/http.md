### Http?

 통신 프로토콜 중 하나로 요즘은 대부분의 웹 통신이 http 통신으로 이루어진다

- http 0.9 - GET 메소드 지원, 헤더 지원x
- http 1.0 - 나머지 메소드 지원, 헤더 지원
- http 1.1 - 현재 보통 사용하고있는 안정화된 버전
- http 2 - 성능 개선
- http 3 - UDP 통신 사용



### Http 1과 2의 차이

 http 통신은 일단 하이퍼텍스트 문서를 교환하기 위해서 만든 통신규약의 일종이다. http 1에서는 전달을 위한 대부분의 규약이 완성되었고 http2에서는 http1의 성능을 개선한 버전이다.



 http1에서는 단점이 있다.  비연결성으로 connection 하나당 하나의 요청만 처리하도록 설계되어 있다. 따라서 동시 전송이 불가능하기 때문에 요청을 할때마다 connection해야하므로 속도가 매우 느리다.



 http2는 이 단점을 해소한다. 한 connection으로 여러개의 메시지를 주고받을 수 있으며 연결에서 모든 메시지가 전달되었을 때 연결이 종료된다. 또한 HTML 문서 안에 있는 파일의 순서를 보장한다. 예를 들어 css와 image 파일이 있을 때 순서없이 image가 먼저 로딩되면 화면 랜더링이 늦어진다. 따라서 http2에서는 리소스간의 우선순위를 둬서 이러한 문제를 해결한다.



### Http의 특징

1. Stateless

    클라이언트와 서버가 통신한다고 가정했을 때 http 통신에서는 서버가 클라이언트의 상태를 저장하지 않는다.

    따라서 중간에 서버가 끊기거나 변경이 되어도 문제없이 응답이 가능하며, 이로인해 응답서버의 확장성을 올릴 수 있는 원인이 된다.

    하지만 세션과 같이 서버에서 status한 통신을 하게 될 경우가 있긴 하다.

2. 비연결성

    클라이언트와 서버가 연결을 했을 때 클라이언트 요청에 대해서 서버가 응답을 하면 연결을 끊어버린다.

    다수의 클라이언트가 접속해있다면 많은 자원이 낭비되므로 비연결성을 통해서 트래픽이 증가했을 때 문제를 해결할 수 있다.

    단 클라이언트의 모든 요청에 대해 매번 새로운 연결의 시도/해제, 즉 3 way handshake와 같은 복잡한 행위를 진행하기 때문에 매우 느리다. 따라서 지속연결을 하게된다.

    지속 연결은 패킷 교환이 진행될 때 패킷에 반응이 없을때가 되었을때 연결을 끊는 것이다.



### Http와 Https

### Http문제점

 Http는 암호화되어서 사용하지 않는 프로토콜이기 때문에 도청이나 위장, 변조가 발생한다.

 TCPIP의 패킷을 수집하는 것만으로도 통신을 도청할 수 있고, 통신 상대를 확인하지 않기 때문에 누구든지 리퀘스트를 할 수 있다. 또한 서버 또는 클라이언트에서 수신한 내용이 송신 측이 발송한 내용과 일치한다는 보장을 할 수도 없다.



 이를 방지하기 위해서 Http 통신 자체에 암호화와 인증을 더해서 보완한 것이 Https이다.

 Https에서 s는 source socket이다. 즉 http에 source socket을 추가한 것으로 Http 통신을하는 소켓 부분을 SSL 프로토콜로 대체한다. 즉, Http는 SSL과 통신하고 SSL이 TCP와 통신을 하게 되는 것이다. 

 이런 SSL을 통해서 Http 메시지의 콘텐트츨 암호화 하거나, 상대를 확인하는 수단으로써 활용한다.



 SSL은 공통키 암호화와 공개키 암호화를 혼합한 하이브리드 암호 시스템을 사용한다.

```
A와 B가 통신을 하고 B가 공개키를 가지고 있다고 한다.

1. A가 B의 공개키로 통신에 사용할 공통키를 암호화하고 B로 보낸다.
2. B가 자신의 비밀키로 복호화한다.
3. 복호화한 공통키로 A에게 보낼 메시지를 암호화하여 A로 보낸다.
4. A는 자신의 공통키로 암호문을 복호화한다.
5. 이후로 계속 공통키를 가지고 암호화, 복호화하여 통신한다.
```



### Http 메소드

- GET : 리소스 조회
- POST : 요청 데이터 처리, 주로 등록
- PUT : 리소스 대체, 리소스가 없을 때 생성
- PATCH : 리소스 부분 변경
- DELETE : 리소스 삭제
- HEAD : GET과 내용은 같지만 상태 줄과 헤더만 반환



### GET 방식 - 리소스 조회

 전달할 데이터를 Http Request Body에 담아서 보내는 것이 아닌 스타트라인의 url에 쿼리스트링의 형태로 전달한다. url이 노출되는 형태이다. 아스키 코드 문자 타입의 데이터만 전달이 가능하다.



### POST 방식 - 요청 데이터 처리

 전달할 데이터를 Http message Body에 담아서 전송할 수 있다. 단순 조회에 사용하는 GET과는 다르게 데이터를 처리하는 것이 주 목적이다.

 주로 요청 데이터 처리, 혹은 값 변경을 넘어거서 프로세스를 처리하는데 사용되는 메소드이다.



### GET vs POST

 GET방식은 요청 데이터를 전달할 때 전달하는 값 자체가 url에 포함되어서 전송하기 때문에 특정 민감 데이터를 전송할 때는 GET 쿼리 스트링 전달을 지양해야하고, 대신 POST는 패킷 탈취가 일어나기 전까진 데이터를 까게될 일은 없으니 민감한 정보는 기본적으로 POST로 전달한다.

 GET 방식은 대신 브라우저에 url을 캐싱하기 때문에 일정 부분 조회만 놓고 본다면 더 빠르다고 볼 수 있다.

 GET도 최근 버전들은 대부분 message body를 사용할 수 있지만 기존에 message body를 GET 방식에서 허용하지 않는 서버들이 있기 때문에 유의해서 사용해야 한다.





### PUT 방식 - 리소스를 대체

 기존 파일에 붙여넣기해서 덮어쓰는 것과 동일함.

### PATCH 방식 - 리소스를 변경

 put과 다르게 기존에 있는 리소스에서 일부분을 변경한다. 사실상 update에 해당됨

### DELETE 방식 - 리소스를 제거





### Http 메소드 속성

1. 안전성

    호출해도 리소스가 변하지 않는 속성이다.

    결국 조회에 해당하는 get이나 head만 이에 해당한다.

2. 멱등성

    몇번을 똑같은 메소드를 호출해도 결과가 변하지 않는 속성이다.

    

   ```java
   f(f(x)) = f(x)
   ```

    POST는 프로세스를 "처리"하는 메소드이기 때문에 몇번을 호출하면 그때마다 결과가 변화한다. 예를 들어 결제에 대한 프로세스를 처리하는 요청이라면 n번 요청하면 n번 결제가 된다.

    단, 외부 요인에 대한 멱등은 고려하지 않는다.



### Http 상태 코드

```
1xx : 처리중

2xx : 정상 처리 완료

3xx : 리다이랙트(추가 행동 필요)

4xx : 클라이언트 요청 오류

5xx : 서버 요청 오류
```



### 2xx

 성공했을 때 전달하는 상태코드이다.

1. 200 : ok, 조건없이 성공된 상태
2. 201 : created, 리소스 생성이 성공했을 때
3. 202 : accepted, 요청 처리는 하는데 대기중인 상태 - 배치성
4. 204 : no content, 성공했는데 응답 메시지 보낼것 없을때



### 3xx

 리다이렉트, 즉 추가적인 행동이 필요할 때 전달하는 상태코드이다. 응답 메시지에 Location 헤더가 존재하면 그 위치로 리다이렉트 해준다.



1. 영구 리다이렉트 : 301, 308
2. 임시적 리다이렉트 : 302, 307, 303



 **리다이렉트를 쓰는 이유**

 요청이 반복되었을 때 POST가 들어갔지만 이후 요청이 POST로 프로세스 처리가 되지 않아야할 때 사용한다.

 예를 들어 결제 프로세스를 POST로 전달한다고 해보자. `"/order"` POST로 결제 요청을 했고 서버는 이를 확인하고 결제 완료된 정보를 전달한다. 만약 결제 완료된 정보가 담긴 페이지에서 사용자가 **"새로고침"**을 한다면 POST로 또 결제 요청이 가는 것이고 이는 심각한 문제가 될 수 있다.

 따라서 POST로 서버가 요청을 받은 후 302로 리다이렉트 메시지를 보냄으로써 클라이언트는 POST였던 메소드를 GET으로 변경하여 이러한 중복 프로세스 처리에 대한 문제점을 막을 수 있는 것이다.



### 4xx

 클라이언트 요청 오류. 5xx와의 차이점은 5xx는 서버 요청 오류이기 때문에 서버가 정상화되거나 할 경우 성공할 여지가 있지만 4xx 오류는 똑같은 요청을 계속 날려도 항상 오류가 발생한다.



1. 401 : 인증 에러
2. 403 : 권한 에러
3. 404 : 요청된 리소스 에러, 추가적으로 권한이 부족한 에러



### 5xx

 서버 요청 오류



1. 500 : 서버 내부 문제 오류
2. 503 : 서버 과부하, 예정된 작업 처리로 잠시 요청 처리 불가





### TCP와 UDP



### UDP

 비 연결형 프로토콜로 TCP와 다르게 캡슐화하거나 연결 설정을 하지 않고 ip 정보를 전달하는 방법을 제공한다.

 UDP는 흐름제어, 오류제어에 따른 수신에 대한 재 전송을 하지 않기 때문에 모두 사용자 프로세스의 몫이 된다. 따라서 보통 UDP는 클라이언트와 서버간의 통신에서 짧은 요청과 응답을 하는데 자주 사용된다. 가장 대표적인 사용처가 DNS이다. 호스트 네임에 대한 IP 주소를 찾아야 할 때 DNS 서버로 호스트네임을 포함한 UDP 패킷을 전달하며 DNS 서버는 해당되는 IP 주소를 포함한 UDP 패킷을 전달한다. 굳이 서로에 대한 연결과 해제가 필요하지 않다.



 추가적으로 실시간 멀티미디어 분야에도 사용한다. **실시간 트랜스포트 프로토콜(RTP)** 즉, 오디오와 비디오 데이터를 UDP 패킷의 형태로 전달하는 프로토콜이다. 전달, 지연, 손실에 대한 보장이 없기 때문에 몇가지 장치들을 제공하기는 한다. 각 패킷은 바로 전 패킷보다 한단계 높게 번호가 새겨져서 전달된다. 따라서 이를 통해서 어떤 패킷이 손실되었는지를 확인할 수 있다. 패킷이 없다면 이를 획득하기 위해서 클라이언트에서는 보간을 통해서 손실한 값에 대한 근사치를 얻어 사용한다.

 확인 응답이 없고, 재전송을 요청하는 매커니즘도 없기 때문이다.



### TCP

  TCP 프로토콜은 신뢰성 없는 인터넷에서 소켓이라는 형태의 종단점을 생성함으로써 안전하게 통신을 하기위해서 생겨난 프로토콜이다.

 모든 TCP 연결은 전이중, 점대점 방식으로 되어있다.

 전이중 방식은 전송이 양방향에서 일어날 수 있음을 의미하며 점대점 방식은 2개의 종단점을 가지고 있음을 의미한다. **즉, TCP 프로토콜은 양쪽 두 위치에서 서로 양방향으로 전송이 이루어지는 통신이다.**

 TCP 프로토콜의 연결은 보통 3way handshake를 통해서 이루어진다.



### 흐름제어/혼잡제어

 TCP 프로토콜은 신뢰할 수 있는 통신을 위해서 4가지 문제점이 존재한다.

- packet 손실
- packet 순서 변경
- 네트워크 혼잡
- receiver가 overload되는 문제

 따라서 TCP 프로토콜은 신뢰할 수 있는 통신을 위해서 흐름제어와 혼잡제어를 진행해주어야한다.

 흐름제어는 송신측과 수신측의 데이터 처리 속도 차이를 해결하는 기법이며 혼잡제어는 송신측의 데이터 전달과 네트워크 처리 속도 차이를 해결하기 위한 기법이다.



1. 흐름제어

 수신측이 송신측 대비해서 처리 속도가 빠른 것은 상관이 없으나 송신측이 더 빠르다면 문제가 된다. 송신이 데이터를 계속 주는데 비해 수신이 느리게 받으면 수신에서 받을 수 있는 저장 데이터가 초과됐을 때 손실이 날 수 있기 때문이다. 이를 위해서 슬라이딩 윈도우를 사용한다.

 윈도우에 포함되는 모든 패킷을 전송하고, 그 패킷들의 전달이 확인되는대로 윈도우를 옆으로 슬라이딩함으로써 다음 패킷을 전달하는 방식이다.



2. 혼잡제어

 송신측 데이터 전달과 네트워크 데이터 처리 속도 차이를 해결하기 위함이다.

 한 라우터에 데이터가 쏠리게 될 경우 자신에게 온 데이터를 전부 처리를 할 수는 없다. 이때 호스트는 또 다시 재전송을 하게되고 결국 혼잡해지게 된다. 이때 송신측에서 보내는 데이터의 전송 속도를 강제로 줄여서 혼잡제어를 한다.



### 웹 브라우저 통신 흐름

1. www.naver.com을 브라우저 주소에 친다.
2. 브라우저는 캐싱된 DNS 주소들을 보면서 www.naver.com에 대응되는 IP주소가 있는지 확인한다.
3. 없으면 systemcall을 통해 os가 저장하고 있는 DNS주소에 대응되는 IP주소가 있는지 확인하낟.
4. 그다음 router 캐시를 확인한다.
5. 그다음 isp에 해당 DNS 주소가 있는지 확인한다.
6. 클라이언트와 서버가 이제 TCP connection을 한다.

```
일반적으로 TCP connection은 3 way handshake 방식을 사용한다.
1. 클라이언트가 서버 접속 요청하는 SYN 패킷을 전달한다.
2. 서버는 받고 SYN과 ACK 패킷을 전달한다.
3. 클라이언트는 서버가 보낸 ACK, SYN 패킷을 받고 ACK를 서버로 전달하면 연결된다.
```

7. 클라이언트가 서버로 http 요청 메시지를 발송한다.
8. 서버가 요청을 처리하고 http 응답 메시지를 생성하여 클라이언트로 전달한다.
9. 클라이언트가 응답메시지로 부터 html content를 보여준다.



### 4 way handshake

 tcp connection의 연결해제에서 4 way handshake를 사용한다.



1. 클라이언트가 연결을 종료한다는 FIN 플래그를 서버로 전달한다.
2. 서버는 FIN을 받고 확인했다는 메시지 ACK를 전달한다.
3. 잠시 데이터를 보낼 때까지 TIME OUT
4. 서버는 클라이언트로 연결을 종료한다는 FIN 플래그를 전달한다.
5. 클라이언트는 FIN 플래그를 확인했다는 메시지 ACK를 전달한다.
6. 클라이언트의 ACK 메시지를 받은 서버는 소켓 연결을 종료한다.
7. 클라이언트는 서버로 부터 받지 못한 데이터가 있을 수 있느니 잠시 대기한다.



### DNS?

 IP 주소를 사람이 이해하기 쉽게 도메인 이름으로 매칭시켜주는 시스템이다.

- 루트 도메인 : 최상위 계층, '.'
- 최상위 레벨 도메인 : 국가 ( com, kr ...)
- 2계층 레벨 도메인 : 기관
- 최하위 레벨 도메인 : 서버 이름

